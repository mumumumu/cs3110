module RegexpUtil
  : sig
    type regexp =
        Epsilon
      | Char of char
      | Union of regexp * regexp
      | Concat of regexp * regexp
      | Star of regexp
      | Fuzzy of char list * int

    val parse : string -> regexp
  end
  = struct

    (********************* GENERATED PARSER CODE ********************)
    type token =
      | EOF
      | CHAR of (char)
      | LPAREN
      | RPAREN
      | LBRACE
      | RBRACE
      | INT of (int)
      | COMMA
      | STAR
      | OR

    open Parsing;;
    # 2 "regexp_grammar.mly"
    type regexp =
        Epsilon
      | Char of char
      | Union of regexp * regexp
      | Concat of regexp * regexp
      | Star of regexp
      | Fuzzy of char list * int
          # 23 "regexp_grammar.ml"
    let yytransl_const = [|
      0 (* EOF *);
      258 (* LPAREN *);
      259 (* RPAREN *);
      260 (* LBRACE *);
      261 (* RBRACE *);
      263 (* COMMA *);
      264 (* STAR *);
      265 (* OR *);
      0|]

    let yytransl_block = [|
      257 (* CHAR *);
      262 (* INT *);
      0|]

    let yylhs = "\255\255\
\001\000\001\000\002\000\002\000\003\000\003\000\003\000\004\000\
\004\000\004\000\005\000\005\000\000\000"

    let yylen = "\002\000\
\002\000\001\000\002\000\001\000\002\000\003\000\001\000\001\000\
\005\000\003\000\002\000\001\000\002\000"

    let yydefred = "\000\000\
\000\000\000\000\002\000\008\000\000\000\000\000\013\000\000\000\
\000\000\000\000\000\000\000\000\000\000\001\000\003\000\005\000\
\000\000\010\000\011\000\000\000\006\000\000\000\009\000"

    let yydgoto = "\002\000\
\007\000\008\000\009\000\010\000\013\000"

    let yysindex = "\009\000\
\005\000\000\000\000\000\000\000\007\255\005\255\000\000\012\000\
\007\255\250\254\010\255\005\255\008\255\000\000\000\000\000\000\
\007\255\000\000\000\000\011\255\000\000\009\255\000\000"

    let yyrindex = "\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\007\000\001\000\000\000\012\255\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000"

    let yygindex = "\000\000\
\000\000\251\255\255\255\000\000\006\000"

    let yytablesize = 266
    let yytable = "\011\000\
\007\000\016\000\017\000\015\000\003\000\012\000\004\000\004\000\
\005\000\001\000\006\000\014\000\018\000\023\000\020\000\021\000\
\022\000\019\000\012\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\007\000\007\000\007\000\007\000\004\000\005\000\000\000\
\006\000\004\000"

    let yycheck = "\005\000\
\000\000\008\001\009\001\009\000\000\000\001\001\000\000\001\001\
\002\001\001\000\004\001\000\000\003\001\005\001\007\001\017\000\
\006\001\012\000\007\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\001\001\002\001\003\001\004\001\001\001\002\001\255\255\
\004\001\003\001"

    let yynames_const = "\
  EOF\000\
  LPAREN\000\
  RPAREN\000\
  LBRACE\000\
  RBRACE\000\
  COMMA\000\
  STAR\000\
  OR\000\
  "

    let yynames_block = "\
  CHAR\000\
  INT\000\
  "

    let yyact = [|
      (fun _ -> failwith "parser")
      ; (fun __caml_parser_env ->
        let _1 = (Parsing.peek_val __caml_parser_env 1 : regexp) in
        Obj.repr(
          # 33 "regexp_grammar.mly"
            ( _1 )
            # 165 "regexp_grammar.ml"
            : regexp))
      ; (fun __caml_parser_env ->
        Obj.repr(
          # 34 "regexp_grammar.mly"
            ( Epsilon )
            # 171 "regexp_grammar.ml"
            : regexp))
      ; (fun __caml_parser_env ->
        let _1 = (Parsing.peek_val __caml_parser_env 1 : regexp) in
        let _2 = (Parsing.peek_val __caml_parser_env 0 : regexp) in
        Obj.repr(
          # 36 "regexp_grammar.mly"
            ( Concat (_1, _2) )
            # 179 "regexp_grammar.ml"
            : regexp))
      ; (fun __caml_parser_env ->
        let _1 = (Parsing.peek_val __caml_parser_env 0 : regexp) in
        Obj.repr(
          # 37 "regexp_grammar.mly"
            ( _1 )
            # 186 "regexp_grammar.ml"
            : regexp))
      ; (fun __caml_parser_env ->
        let _1 = (Parsing.peek_val __caml_parser_env 1 : regexp) in
        Obj.repr(
          # 39 "regexp_grammar.mly"
            ( Star _1 )
            # 193 "regexp_grammar.ml"
            : regexp))
      ; (fun __caml_parser_env ->
        let _1 = (Parsing.peek_val __caml_parser_env 2 : regexp) in
        let _3 = (Parsing.peek_val __caml_parser_env 0 : regexp) in
        Obj.repr(
          # 40 "regexp_grammar.mly"
            ( Union (_1, _3) )
            # 201 "regexp_grammar.ml"
            : regexp))
      ; (fun __caml_parser_env ->
        let _1 = (Parsing.peek_val __caml_parser_env 0 : regexp) in
        Obj.repr(
          # 41 "regexp_grammar.mly"
            ( _1 )
            # 208 "regexp_grammar.ml"
            : regexp))
      ; (fun __caml_parser_env ->
        let _1 = (Parsing.peek_val __caml_parser_env 0 : char) in
        Obj.repr(
          # 43 "regexp_grammar.mly"
            ( Char _1 )
            # 215 "regexp_grammar.ml"
            : regexp))
      ; (fun __caml_parser_env ->
        let _2 = (Parsing.peek_val __caml_parser_env 3 : char list) in
        let _4 = (Parsing.peek_val __caml_parser_env 1 : int) in
        Obj.repr(
          # 44 "regexp_grammar.mly"
            ( Fuzzy (_2, _4) )
            # 223 "regexp_grammar.ml"
            : regexp))
      ; (fun __caml_parser_env ->
        let _2 = (Parsing.peek_val __caml_parser_env 1 : regexp) in
        Obj.repr(
          # 45 "regexp_grammar.mly"
            ( _2 )
            # 230 "regexp_grammar.ml"
            : regexp))
      ; (fun __caml_parser_env ->
        let _1 = (Parsing.peek_val __caml_parser_env 1 : char) in
        let _2 = (Parsing.peek_val __caml_parser_env 0 : char list) in
        Obj.repr(
          # 47 "regexp_grammar.mly"
            ( _1 :: _2 )
            # 238 "regexp_grammar.ml"
            : char list))
      ; (fun __caml_parser_env ->
        let _1 = (Parsing.peek_val __caml_parser_env 0 : char) in
        Obj.repr(
          # 48 "regexp_grammar.mly"
            ( [_1] )
            # 245 "regexp_grammar.ml"
            : char list))
      (* Entry main *)
      ; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
                |]
    let yytables =
      { Parsing.actions=yyact;
        Parsing.transl_const=yytransl_const;
        Parsing.transl_block=yytransl_block;
        Parsing.lhs=yylhs;
        Parsing.len=yylen;
        Parsing.defred=yydefred;
        Parsing.dgoto=yydgoto;
        Parsing.sindex=yysindex;
        Parsing.rindex=yyrindex;
        Parsing.gindex=yygindex;
        Parsing.tablesize=yytablesize;
        Parsing.table=yytable;
        Parsing.check=yycheck;
        Parsing.error_function=parse_error;
        Parsing.names_const=yynames_const;
        Parsing.names_block=yynames_block }
    let main (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
      (Parsing.yyparse yytables 1 lexfun lexbuf : regexp)

    (********************* GENERATED LEXER CODE ********************)
        # 1 "regexp_lexer.mll"

    exception LexError

      # 6 "regexp_lexer.ml"
    let __ocaml_lex_tables = {
      Lexing.lex_base =
        "\000\000\246\255\247\255\248\255\249\255\250\255\251\255\252\255\
    \253\255\254\255\010\000";
      Lexing.lex_backtrk =
        "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\000\000";
      Lexing.lex_default =
        "\255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\255\255";
      Lexing.lex_trans =
        "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \008\000\007\000\003\000\000\000\004\000\000\000\000\000\000\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\
    \009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\
    \009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\
    \009\000\009\000\009\000\006\000\002\000\005\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000";
      Lexing.lex_check =
        "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\000\000\000\000\255\255\000\000\255\255\255\255\255\255\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255";
      Lexing.lex_base_code =
        "";
      Lexing.lex_backtrk_code =
        "";
      Lexing.lex_default_code =
        "";
      Lexing.lex_trans_code =
        "";
      Lexing.lex_check_code =
        "";
      Lexing.lex_code =
        "";
    }

    let rec token lexbuf =
      __ocaml_lex_token_rec lexbuf 0
    and __ocaml_lex_token_rec lexbuf __ocaml_lex_state =
      match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
        | 0 ->
          let
              # 9 "regexp_lexer.mll"
                n
                # 109 "regexp_lexer.ml"
              = Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in
          # 9 "regexp_lexer.mll"
            ( INT (int_of_string n) )
            # 113 "regexp_lexer.ml"

        | 1 ->
          let
              # 10 "regexp_lexer.mll"
                c
                # 119 "regexp_lexer.ml"
              = Lexing.sub_lexeme_char lexbuf lexbuf.Lexing.lex_start_pos in
          # 10 "regexp_lexer.mll"
            ( CHAR c )
            # 123 "regexp_lexer.ml"

        | 2 ->
          # 11 "regexp_lexer.mll"
            ( LPAREN )
            # 128 "regexp_lexer.ml"

        | 3 ->
          # 12 "regexp_lexer.mll"
            ( RPAREN )
            # 133 "regexp_lexer.ml"

        | 4 ->
          # 13 "regexp_lexer.mll"
            ( LBRACE )
            # 138 "regexp_lexer.ml"

        | 5 ->
          # 14 "regexp_lexer.mll"
            ( RBRACE )
            # 143 "regexp_lexer.ml"

        | 6 ->
          # 15 "regexp_lexer.mll"
            ( COMMA )
            # 148 "regexp_lexer.ml"

        | 7 ->
          # 16 "regexp_lexer.mll"
            ( STAR )
            # 153 "regexp_lexer.ml"

        | 8 ->
          # 17 "regexp_lexer.mll"
            ( OR )
            # 158 "regexp_lexer.ml"

        | 9 ->
          # 18 "regexp_lexer.mll"
            ( EOF )
            # 163 "regexp_lexer.ml"

        | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf;
          __ocaml_lex_token_rec lexbuf __ocaml_lex_state
    ;;

    let parse str = main token (Lexing.from_string str)
  end
